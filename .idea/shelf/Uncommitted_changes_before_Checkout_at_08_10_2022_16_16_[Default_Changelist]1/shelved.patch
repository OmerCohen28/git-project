Index: human_dumb_client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from socket import *\r\n# import re\r\n# import random\r\n\r\n\r\nclass Client:\r\n    def __init__(self):\r\n        self.cards = []\r\n        self.client = socket(AF_INET, SOCK_STREAM)\r\n        self.init_sock()\r\n\r\n        self.strong = \"\"\r\n\r\n    def init_sock(self):\r\n        self.client.connect((\"localhost\", 55555))\r\n\r\n    def start_game(self):\r\n        my_id, work = self.recv()\r\n        if not work:\r\n            print(f\"error when recv id {my_id}\")\r\n            exit()\r\n        my_id = my_id.split(\":\")[1]\r\n        print(my_id)\r\n\r\n        ruler, work = self.recv()\r\n        if not work:\r\n            print(f\"error when recv ruler {ruler}\")\r\n            exit()\r\n\r\n        print(ruler)\r\n        ruler = ruler.split(\":\")[1]\r\n\r\n        first_5_cards, work = self.recv()\r\n\r\n        if not work:\r\n            print(f\"error when recv 5 cards {first_5_cards}\")\r\n            exit()\r\n        first_5_cards = first_5_cards.split(\"|\")\r\n        if ruler == my_id:\r\n            print(*[f\"{i}-{card}\" for i, card in enumerate(first_5_cards)])\r\n            strong = input(\"enter strong index: \")\r\n            strong_to_send = first_5_cards[int(strong)].split(\"*\")[0]\r\n            print(strong_to_send)\r\n            self.send(f\"set_strong:{strong_to_send}\")\r\n            print(\"after send suit\")\r\n            response, work = self.recv()\r\n            print(\"after recv response\")\r\n            if not work:\r\n                print(f\"error when recv response strong {response}\")\r\n                exit()\r\n            print(response)\r\n\r\n        cards_teams_strong, work = self.recv()\r\n        if not work:\r\n            print(f\"error when recv cards_teams_strong {cards_teams_strong}\")\r\n            exit()\r\n        print(cards_teams_strong)\r\n        cards, teams, strong = cards_teams_strong.split(\",\")\r\n        self.cards = [(c.split(\"*\")[0], c.split(\"*\")[1]) for c in cards.split(\"|\")]\r\n        print(teams, strong)\r\n\r\n        self.strong = strong.split(\":\")[1]\r\n\r\n        self.start_turn()\r\n\r\n    def start_turn(self):\r\n        while True:\r\n            status, work = self.recv()\r\n            if not work:\r\n                print(f\"error when recv status {status}\")\r\n                exit()\r\n\r\n            if status == \"GAME_OVER\":\r\n                print(\"game over!!!!!!!!!!!!\")\r\n                exit()\r\n            elif status == \"PLAYER_DISCONNECTED\":\r\n                print(\"player disconnected\")\r\n                exit()\r\n            print(status)\r\n\r\n            print(*[f\"{i}-{card}\" for i, card in enumerate(self.cards)])\r\n            # index = input(\"which card to play: \")\r\n            # card = self.cards[int(index)]\r\n\r\n            played_suit = status.split(\",\")[0].split(\":\")[1]\r\n\r\n            card = self.choose_card(played_suit)\r\n            print(card)\r\n\r\n            self.send(f\"play_card:{'*'.join(card)}\")\r\n\r\n            response, work = self.recv()\r\n\r\n            if not work:\r\n                print(f\"error when recv response play {response}\")\r\n                exit()\r\n            print(\"response:\", response)\r\n\r\n            if response == \"ok\":\r\n                self.cards.remove(card)\r\n            else:\r\n                print(\"ERROR!!!!!!!!!!\")\r\n\r\n            game_status, work = self.recv()\r\n            if not work:\r\n                print(f\"error when recv game status {game_status}\")\r\n                exit()\r\n\r\n            if game_status == \"PLAYER_DISCONNECTED\":\r\n                print(\"player disconnected\")\r\n                exit()\r\n            print(game_status)\r\n\r\n    def choose_card(self, played_suit):\r\n        if played_suit == \"\":\r\n            return self.cards[0]\r\n\r\n        for card in self.cards:\r\n            if card[0] == played_suit:\r\n                return card\r\n\r\n        for card in self.cards:\r\n            if card[0] == self.strong:\r\n                return card\r\n\r\n        return self.cards[0]\r\n\r\n    def recv(self):\r\n        try:\r\n            msg_size = self.client.recv(8)\r\n        except:\r\n            return \"recv error\", False\r\n        if not msg_size:\r\n            return \"msg length error\", False\r\n        try:\r\n            msg_size = int(msg_size)\r\n        except:  # not an integer\r\n            return \"msg length error\", False\r\n\r\n        msg = b''\r\n        while len(msg) < msg_size:  # this is a fail - safe -> if the recv not giving the msg in one time\r\n            try:\r\n                msg_fragment = self.client.recv(msg_size - len(msg))\r\n            except:\r\n                return \"recv error\", False\r\n            if not msg_fragment:\r\n                return \"msg data is none\", False\r\n            msg = msg + msg_fragment\r\n\r\n        msg = msg.decode(errors=\"ignore\")\r\n\r\n        return msg, True\r\n\r\n    def send(self, data):\r\n        self.client.send(str(len(data.encode())).zfill(8).encode() + data.encode())\r\n\r\n\r\nclient = Client()\r\nclient.start_game()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/human_dumb_client.py b/human_dumb_client.py
--- a/human_dumb_client.py	
+++ b/human_dumb_client.py	
@@ -71,21 +71,21 @@
                 exit()
 
             if status == "GAME_OVER":
-                print("game over!!!!!!!!!!!!")
+                print("status:", "game over!!!!!!!!!!!!")
                 exit()
             elif status == "PLAYER_DISCONNECTED":
-                print("player disconnected")
+                print("status:", "player disconnected")
                 exit()
-            print(status)
+            print("status:", status)
 
-            print(*[f"{i}-{card}" for i, card in enumerate(self.cards)])
+            print("self cards:", *[f"{i}-{card}" for i, card in enumerate(self.cards)])
             # index = input("which card to play: ")
             # card = self.cards[int(index)]
 
             played_suit = status.split(",")[0].split(":")[1]
 
             card = self.choose_card(played_suit)
-            print(card)
+            print("chosen card:", card)
 
             self.send(f"play_card:{'*'.join(card)}")
 
@@ -107,9 +107,9 @@
                 exit()
 
             if game_status == "PLAYER_DISCONNECTED":
-                print("player disconnected")
+                print("game status:", "player disconnected")
                 exit()
-            print(game_status)
+            print("game status:", game_status)
 
     def choose_card(self, played_suit):
         if played_suit == "":
Index: server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nimport time\r\nfrom select import select\r\n\r\n\r\nclass Server:\r\n    def __init__(self, ip, port):\r\n        \"\"\"\r\n        setting up the class of the base server which handles the socket level\r\n        :param ip: str - server ip to bind\r\n        :param port: int - server port to bind\r\n        \"\"\"\r\n        self.__ip = ip\r\n        self.__port = port\r\n\r\n        self.__clients = []\r\n        self.__client_ids = {}\r\n        self.__messages_to_send = []\r\n        self.__setup_socket()\r\n\r\n        self.run = False\r\n\r\n        self.server_gui_sock = None\r\n\r\n    def __setup_socket(self):\r\n        \"\"\"\r\n        setting up the server socket object\r\n        :return: None\r\n        \"\"\"\r\n        self.__server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        self.__server_socket.bind((self.__ip, self.__port))\r\n\r\n    def start(self):\r\n        \"\"\"\r\n        starting the server's socket and mainloop\r\n        :return: None\r\n        \"\"\"\r\n        self.__server_socket.listen()\r\n\r\n        self.__main_loop()\r\n\r\n    def close(self):\r\n        \"\"\"\r\n        closing server socket\r\n        :return: None\r\n        \"\"\"\r\n        print(f\"[SERVER] server closed\")\r\n        self.__server_socket.close()\r\n\r\n    def __close_client(self, client):\r\n        \"\"\"\r\n        closing connection to a client\r\n        :param client: socket - client socket object\r\n        :return: None\r\n        \"\"\"\r\n        print(f\"[SERVER] {client.getpeername()} disconnected\")\r\n        self.__clients.remove(client)\r\n        client.close()\r\n\r\n    def send_message(self, client_id, msg):\r\n        \"\"\"\r\n        adding message that need to be sent to the message list\r\n        :param client_id: int - id of a player client\r\n        :param msg: str\r\n        :return: None\r\n        \"\"\"\r\n\r\n        client_sock = [sock for sock, _id in self.__client_ids.items() if _id == client_id]\r\n        client_sock = client_sock[0]\r\n\r\n        self.__messages_to_send.append((client_sock, msg))\r\n\r\n    def send_to_server_gui(self, msg):\r\n        \"\"\"\r\n        adding the message that need to be sent to the server gui to the message list\r\n        :param msg: str\r\n        :return:\r\n        \"\"\"\r\n\r\n        self.__messages_to_send.append((self.server_gui_sock, msg))\r\n\r\n    def send_all(self, msg):\r\n        \"\"\"\r\n                adding message that need to be sent to the message list for all players\r\n                :param msg: str\r\n                :return: None\r\n                \"\"\"\r\n\r\n        for client_sock in self.__clients:\r\n            if client_sock is not self.server_gui_sock:\r\n                if msg == \"GAME_OVER\":\r\n                    print(f\"game over(2) for {self.__client_ids[client_sock]}\")\r\n                self.__messages_to_send.append((client_sock, msg))\r\n\r\n    def _handle_data(self, client_id, msg, msg_type=\"data\"):\r\n        \"\"\"\r\n        method to be overwritten by handler class\r\n        :return: None\r\n        \"\"\"\r\n        # example - echo and not closing the server\r\n        if msg_type == \"data\":\r\n            self.send_message(client_id, msg)\r\n\r\n    def __main_loop(self):\r\n        \"\"\"\r\n        server main loop that handles socket with select\r\n        :return: None\r\n        \"\"\"\r\n        print(\"server started\")\r\n        self.run = True\r\n        # main server loop\r\n        wlist = []\r\n        while self.run:\r\n            rlist, wlist, _ = select(self.__clients + [self.__server_socket], self.__clients, [])\r\n\r\n            # handling readable sockets\r\n            for sock in rlist:\r\n                # handling new client\r\n                if sock is self.__server_socket:\r\n                    try:\r\n                        new_client, addr = self.__server_socket.accept()\r\n                    except:\r\n                        self.close()\r\n                        return\r\n                    print(f\"[SERVER] new connection from {addr}\")\r\n                    self.__clients.append(new_client)\r\n                    if len(self.__clients) > 1 or self.server_gui_sock:\r\n                        self.__client_ids[new_client] = len(self.__clients) - 1\r\n\r\n                        self._handle_data(len(self.__clients) - 1, \"\", msg_type=\"new_client\")\r\n                    else:\r\n                        self.server_gui_sock = new_client\r\n                        print('CONNECTED TO GUI SERVER', self.__clients, self.__client_ids)\r\n\r\n                # handling client request\r\n                else:\r\n                    msg, success = self.__recv_from_socket(sock)\r\n\r\n                    if not success:\r\n                        self.__close_client(sock)\r\n                        self._handle_data(self.__client_ids[sock], \"\", msg_type=\"client_disconnected\")\r\n                    else:\r\n                        self._handle_data(self.__client_ids[sock], msg)\r\n                    if not self.run:\r\n                        # self.close()\r\n                        # return\r\n                        break\r\n            # print(\"a\")\r\n            # while len(self.__messages_to_send) > 0:\r\n            #     print(\"b\")\r\n            self.__send_messages(wlist)\r\n\r\n        # for clients to recv last messages\r\n        while len(self.__messages_to_send) > 0:\r\n            self.__send_messages(wlist)\r\n        time.sleep(5)\r\n\r\n        self.close()\r\n\r\n    def __send_messages(self, wlist):\r\n        \"\"\"\r\n        this function sends the clients messages that are waiting to be sent by the wanted format\r\n        :param wlist: list[socket] - list of sockets that can be send to\r\n        :return: None\r\n        \"\"\"\r\n        # print(\"wlist is:\", \",\".join([f\"{self.__client_ids[so]}\" for so in wlist]))\r\n        for message in self.__messages_to_send:\r\n            client, data = message\r\n\r\n            # if data == \"GAME_OVER\":\r\n            #     print(f\"game over msg for {self.__client_ids[client]}\")\r\n\r\n            if client not in self.__clients:\r\n                self.__messages_to_send.remove(message)\r\n                continue\r\n            if client in wlist:\r\n                try:\r\n                    # print(f\"sending data to client number {self.__client_ids[client]}\")\r\n                    client.send(str(len(data.encode())).zfill(8).encode() + data.encode())\r\n                except:\r\n                    print(\"error\")\r\n                    # pass\r\n\r\n                self.__messages_to_send.remove(message)\r\n\r\n    def __recv_from_socket(self, sock):\r\n        \"\"\"\r\n        function that receive data from socket by the wanted format\r\n        :param sock: socket\r\n        :return: tuple - (msg/error - str, status(True for ok, False for error))\r\n        \"\"\"\r\n        try:\r\n            msg_size = sock.recv(8)\r\n        except:\r\n            return \"recv error\", False\r\n        if not msg_size:\r\n            return \"msg length error\", False\r\n        try:\r\n            msg_size = int(msg_size)\r\n        except:  # not an integer\r\n            return \"msg length error\", False\r\n\r\n        msg = b''\r\n        while len(msg) < msg_size:  # this is a fail - safe -> if the recv not giving the msg in one time\r\n            try:\r\n                msg_fragment = sock.recv(msg_size - len(msg))\r\n            except:\r\n                return \"recv error\", False\r\n            if not msg_fragment:\r\n                return \"msg data is none\", False\r\n            msg = msg + msg_fragment\r\n\r\n        msg = msg.decode(errors=\"ignore\")\r\n\r\n        return msg, True\r\n\r\n\r\n# for testing purposes\r\nif __name__ == \"__main__\":\r\n     s = Server(\"0.0.0.0\", 55555)\r\n     s.start()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server.py b/server.py
--- a/server.py	
+++ b/server.py	
@@ -166,7 +166,7 @@
         # print("wlist is:", ",".join([f"{self.__client_ids[so]}" for so in wlist]))
         for message in self.__messages_to_send:
             client, data = message
-
+            print(f"msg: {data} for client: {self.__client_ids.get(client, 'server gui')} client in wlist: {client in wlist}")
             # if data == "GAME_OVER":
             #     print(f"game over msg for {self.__client_ids[client]}")
 
Index: handler.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from base_classes import *\r\nfrom server import Server\r\nfrom game import Game\r\nimport random\r\nimport time\r\n\r\n\r\nBAD_CARD_MSG = \"bad_card\"\r\nBAD_PLAY_MSG = \"bad_play\"\r\n\r\nDELAY_BETWEEN_TURNS_IN_SEC = 0.3\r\n\r\n\r\ndef list_to_str(lst, sep=\"|\"):\r\n    \"\"\"\r\n    joins an array to a string with a sep\r\n    :param lst: list\r\n    :param sep: str\r\n    :return: str\r\n    \"\"\"\r\n    return sep.join([str(item) for item in lst])\r\n\r\n\r\nclass Handler(Server):\r\n    def __init__(self, ip=\"0.0.0.0\", port=55555):\r\n        \"\"\"\r\n        setting up the handler server\r\n        :param ip: str\r\n        :param port: int\r\n        \"\"\"\r\n\r\n        super().__init__(ip, port)\r\n\r\n        self.players = []\r\n        self.game = None\r\n        self.current_player = None\r\n        self.played_cards_dict = {1: \"\", 2: \"\", 3: \"\", 4: \"\"}\r\n\r\n    def _handle_data(self, client_id: int, msg: str, msg_type=\"data\"):\r\n        \"\"\"\r\n        function that handles the requests of the players and manages the game\r\n        :param client_id: int - id of the player who sent the request\r\n        :param msg: str - the request of the player\r\n        :param msg_type: str - the type of request that the player sent\r\n        :return: None\r\n        \"\"\"\r\n\r\n        if msg_type == \"new_client\":\r\n            self.handle_new_player(client_id)\r\n        elif msg_type == \"client_disconnected\":\r\n            self.handle_player_disconnect(client_id)\r\n        else:\r\n            if msg.startswith(\"set_strong:\"):\r\n\r\n                suit = msg[len(\"set_strong:\"):]\r\n                self.handle_set_strong_suit(client_id, suit)\r\n            elif msg.startswith(\"play_card:\"):\r\n\r\n                card = msg[len(\"play_card:\"):]\r\n                self.handle_play_card(client_id, card)\r\n\r\n    def handle_set_strong_suit(self, client_id, suit):\r\n        \"\"\"\r\n        sets strong suit to get logic with error checking\r\n        :param client_id: int\r\n        :param suit: str\r\n        :return: None\r\n\r\n        \"\"\"\r\n        if client_id != self.game.ruler.player_id:\r\n            return\r\n\r\n        if self.game.strong_suit is not None:\r\n            return\r\n\r\n        if suit not in Suit.__members__:\r\n            self.send_message(client_id, \"bad\")\r\n        else:\r\n            self.game.set_strong_suit(Suit[suit])\r\n            self.send_message(client_id, \"ok\")\r\n\r\n            self.game.hand_cards_for_all()\r\n\r\n            # sends remaining cards for all players in format: suit*rank|suit*rank...\r\n            for player in self.game.players:\r\n                self.send_message(player.player_id, f\"{list_to_str(player.hand)},teams:{list_to_str(self.game.teams)},strong:{suit}\")\r\n\r\n            # format like this: \"teams:1+3|2+4,strong:DIAMONDS\"\r\n            # self.send_all(f\"teams:{list_to_str(self.game.teams)},strong:{suit}\")\r\n            time.sleep(DELAY_BETWEEN_TURNS_IN_SEC)\r\n            self.start_turn()\r\n\r\n    def start_turn(self):\r\n        \"\"\"\r\n        starts the turn by sending to the player the status on the board\r\n        :return: None\r\n        \"\"\"\r\n\r\n        player = self.game.get_current_player_turn()\r\n        self.current_player = player\r\n\r\n        round_status = self.game.get_round_state()\r\n\r\n        played_cards_by_id = [self.played_cards_dict[1], self.played_cards_dict[2], self.played_cards_dict[3], self.played_cards_dict[4]]\r\n\r\n        msg = f\"played_suit:{'' if round_status.played_suit is None else round_status.played_suit.name},played_cards:{list_to_str(played_cards_by_id)}\"\r\n        self.send_message(player.player_id, msg)\r\n\r\n        #self.update_server_gui()\r\n\r\n        #time.sleep(1)\r\n\r\n    def handle_play_card(self, client_id, str_card):\r\n        \"\"\"\r\n        handles the player playing a card with game logic and error checking and calling the update server gui\r\n        :param client_id: int\r\n        :param str_card: str - card obj in string format\r\n        :return: None\r\n        \"\"\"\r\n\r\n        if self.current_player is None or client_id != self.current_player.player_id:\r\n            return\r\n\r\n        lst_card = str_card.split(\"*\")\r\n\r\n        if len(lst_card) != 2:\r\n            self.send_message(client_id, BAD_CARD_MSG)\r\n            return\r\n        print(\"_____________\", client_id, \"_________\")\r\n        suit, rank = lst_card\r\n        if suit not in Suit.__members__ or rank not in Rank.__members__:\r\n            self.send_message(client_id, BAD_CARD_MSG)\r\n\r\n        card = Card(Suit[suit], Rank[rank])\r\n        valid, round_over_team = self.game.play_card(self.current_player, card)\r\n\r\n        if not valid:\r\n            self.send_message(client_id, BAD_PLAY_MSG)\r\n            return\r\n\r\n        self.send_message(client_id, \"ok\")\r\n\r\n        self.played_cards_dict[client_id] = str_card\r\n\r\n        if round_over_team:\r\n            game_state = self.game.get_game_state()\r\n            scores = game_state.scores\r\n\r\n            self.send_all(f\"round_winner:{round_over_team},scores:{list_to_str([f'{team}*{score}' for team, score in scores.items()])}\")\r\n\r\n            self.update_server_gui()\r\n            self.played_cards_dict = {1: \"\", 2: \"\", 3: \"\", 4: \"\"}\r\n\r\n            if self.game.game_over:\r\n                self.handle_game_over()\r\n                return\r\n        else:\r\n            self.update_server_gui()\r\n            pass\r\n\r\n        time.sleep(DELAY_BETWEEN_TURNS_IN_SEC*2)\r\n\r\n        # start new turn\r\n        self.start_turn()\r\n\r\n    def handle_new_player(self, client_id):\r\n        \"\"\"\r\n        handling new player joining the game\r\n        :param client_id: int\r\n        :return: None\r\n        \"\"\"\r\n\r\n        p = Player()\r\n        self.players.append(p)\r\n\r\n        self.send_message(client_id, f\"client_id:{client_id}\")\r\n\r\n        if len(self.players) == 4:\r\n            self.start_game()\r\n\r\n    def start_game(self):\r\n        \"\"\"\r\n        starts the game when 4 clients are connected, sending cards and deciding ruler\r\n        :return: None\r\n        \"\"\"\r\n\r\n        team1 = Team(self.players[:2])\r\n        team2 = Team(self.players[2:])\r\n\r\n        self.game = Game(self.players, [team1, team2])\r\n\r\n        ruler = random.choice(self.game.players)\r\n        self.game.set_ruler(ruler)\r\n\r\n        self.send_all(f\"ruler:{ruler.player_id}\")\r\n\r\n        self.game.hand_cards_for_all()\r\n\r\n        # sends cards for all players in format: suit*rank|suit*rank...\r\n        for player in self.game.players:\r\n            self.send_message(player.player_id, list_to_str(player.hand))\r\n\r\n    def handle_player_disconnect(self, client_id):\r\n        \"\"\"\r\n        closing the game server when a player disconnect because the game cant continue and sending the players the reason\r\n        :param client_id: int\r\n        :return: None\r\n        \"\"\"\r\n\r\n        self.send_all(f\"PLAYER_DISCONNECTED\")\r\n        self.run = False\r\n\r\n    def handle_game_over(self):\r\n        \"\"\"\r\n        sending the players the game is over and closing the server\r\n        :return:\r\n        \"\"\"\r\n\r\n        self.send_all(f\"GAME_OVER\")\r\n        self.run = False\r\n\r\n    def update_server_gui(self):\r\n        \"\"\"\r\n        sending the the server gui the status of the game so it can show the status\r\n        :return: None\r\n        player format: card|card|card...(all cards)-[played card on board]\r\n        format: player1|player2|player3|player4,score of player 1+3|score of player 2+4 -- numbers are not id nums\r\n        \"\"\"\r\n        score_str = f\"{self.game.teams[0].points}|{self.game.teams[1].points}\"\r\n\r\n        player1_id1_str = f\"{list_to_str(self.game.players[0].hand, '+')}-{self.played_cards_dict[1]}\"\r\n        player2_id3_str = f\"{list_to_str(self.game.players[2].hand, '+')}-{self.played_cards_dict[3]}\"\r\n        player3_id2_str = f\"{list_to_str(self.game.players[1].hand, '+')}-{self.played_cards_dict[2]}\"\r\n        player4_id4_str = f\"{list_to_str(self.game.players[3].hand, '+')}-{self.played_cards_dict[4]}\"\r\n\r\n        players_str = f\"{player1_id1_str}|{player2_id3_str}|{player3_id2_str}|{player4_id4_str}\"\r\n\r\n        self.send_to_server_gui(f\"{players_str}\")\r\n\r\n\r\na = Handler()\r\na.start()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/handler.py b/handler.py
--- a/handler.py	
+++ b/handler.py	
@@ -150,13 +150,13 @@
 
             self.update_server_gui()
             self.played_cards_dict = {1: "", 2: "", 3: "", 4: ""}
-
             if self.game.game_over:
+                time.sleep(1)
                 self.handle_game_over()
                 return
         else:
             self.update_server_gui()
-            pass
+            # pass
 
         time.sleep(DELAY_BETWEEN_TURNS_IN_SEC*2)
 
